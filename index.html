<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Aerochrome Simulator</title>
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    #status { margin: 10px 0; font-weight: bold; }
    canvas { margin-top: 10px; border: 1px solid #ccc; max-width: 100%; }
    label { display: block; margin-top: 10px; }
  </style>
</head>
<body>
  <h2>Aerochrome Simulator 6</h2>

  <label>IR Image: <input type="file" id="irInput" accept="image/*"></label>
  <label>Normal Image: <input type="file" id="visInput" accept="image/*"></label>

  <label>IR intensity (red channel): <input type="range" id="irSlider" min="0" max="200" value="100"> <span id="irValue">100%</span></label>

  <button id="processBtn">Process</button>
  <div id="status">Waiting for input…</div>
  <canvas id="output"></canvas>

  <script>
    let irImg = null, visImg = null;
    let alignedIR = null; // cache aligned IR for slider updates
    let visMatGlobal = null;

    function updateStatus(msg) {
      document.getElementById('status').textContent = msg;
      console.log(msg);
    }

    function loadImage(file, callback) {
      let img = new Image();
      img.onload = () => callback(img);
      img.src = URL.createObjectURL(file);
    }

    function resizeImage(img, maxW = 1000) {
      let scale = Math.min(1, maxW / img.width);
      let canvas = document.createElement('canvas');
      canvas.width = img.width * scale;
      canvas.height = img.height * scale;
      let ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      return cv.imread(canvas);
    }

    function mergeAndDisplay(scale = 1.0) {
      if (!alignedIR || !visMatGlobal) return;

      let visChannels = new cv.MatVector();
      cv.split(visMatGlobal, visChannels);

      let irChannels = new cv.MatVector();
      cv.split(alignedIR, irChannels);

      let irRed = new cv.Mat();
      irChannels.get(0).convertTo(irRed, -1, scale, 0); // faster scaling

      let outChannels = new cv.MatVector();
      outChannels.push_back(irRed);
      outChannels.push_back(visChannels.get(0));
      outChannels.push_back(visChannels.get(1));

      let merged = new cv.Mat();
      cv.merge(outChannels, merged);

      // Optional: downscale for display if too big
      let displayMat = new cv.Mat();
      let maxDisplay = 800;
      let scaleDisplay = Math.min(1, maxDisplay / merged.cols);
      cv.resize(merged, displayMat, new cv.Size(Math.round(merged.cols * scaleDisplay), Math.round(merged.rows * scaleDisplay)));

      cv.imshow("output", displayMat);

      // cleanup
      visChannels.delete(); irChannels.delete(); irRed.delete(); outChannels.delete(); merged.delete(); displayMat.delete();
    }

    function process() {
      if (!irImg || !visImg) {
        updateStatus("Please upload both images.");
        return;
      }

      updateStatus("Starting…");

      let irMat = resizeImage(irImg, 1000);
      let visMat = resizeImage(visImg, 1000);

      updateStatus("Converting to grayscale for alignment…");
      let irGray = new cv.Mat(), visGray = new cv.Mat();
      cv.cvtColor(irMat, irGray, cv.COLOR_RGBA2GRAY);
      cv.cvtColor(visMat, visGray, cv.COLOR_RGBA2GRAY);

      updateStatus("Detecting keypoints with ORB…");
      let detector = new cv.ORB(200);
      let kp1 = new cv.KeyPointVector(), kp2 = new cv.KeyPointVector();
      let des1 = new cv.Mat(), des2 = new cv.Mat();
      detector.detectAndCompute(irGray, new cv.Mat(), kp1, des1);
      detector.detectAndCompute(visGray, new cv.Mat(), kp2, des2);

      updateStatus("Matching keypoints…");
      let bf = new cv.BFMatcher(cv.NORM_HAMMING, false);
      let matches = new cv.DMatchVectorVector();
      bf.knnMatch(des1, des2, matches, 2);

      let good = [];
      for (let i = 0; i < matches.size(); i++) {
        let m = matches.get(i).get(0);
        let n = matches.get(i).get(1);
        if (m.distance < 0.75 * n.distance) good.push(m);
      }

      if (good.length < 4) {
        updateStatus("Not enough matches, skipping alignment.");
        alignedIR = irMat.clone();
      } else {
        updateStatus("Computing homography…");
        let srcPts = [], dstPts = [];
        for (let m of good) {
          srcPts.push(kp1.get(m.queryIdx).pt.x, kp1.get(m.queryIdx).pt.y);
          dstPts.push(kp2.get(m.trainIdx).pt.x, kp2.get(m.trainIdx).pt.y);
        }
        let src = cv.matFromArray(good.length, 1, cv.CV_32FC2, srcPts);
        let dst = cv.matFromArray(good.length, 1, cv.CV_32FC2, dstPts);
        let H = cv.findHomography(src, dst, cv.RANSAC);

        if (H.empty()) {
          updateStatus("Homography failed, skipping alignment.");
          alignedIR = irMat.clone();
        } else {
          updateStatus("Warping IR image…");
          alignedIR = new cv.Mat();
          cv.warpPerspective(irMat, alignedIR, H, new cv.Size(visMat.cols, visMat.rows));
        }

        src.delete(); dst.delete(); H.delete();
      }

      // cache visMat for slider updates
      visMatGlobal = visMat.clone();

      // initial display
      let scale = document.getElementById('irSlider').value / 100;
      updateStatus("Merging channels…");
      mergeAndDisplay(scale);

      updateStatus("Done!");

      // cleanup
      irMat.delete(); irGray.delete(); visGray.delete();
      kp1.delete(); kp2.delete(); des1.delete(); des2.delete();
      detector.delete(); bf.delete(); matches.delete();
    }

    function waitForCV(callback) {
      if (cv && cv.Mat) callback();
      else setTimeout(() => waitForCV(callback), 100);
    }

    document.getElementById('processBtn').addEventListener('click', () => {
      waitForCV(process);
    });

    document.getElementById('irInput').addEventListener('change', e => {
      loadImage(e.target.files[0], img => irImg = img);
    });
    document.getElementById('visInput').addEventListener('change', e => {
      loadImage(e.target.files[0], img => visImg = img);
    });

    document.getElementById('irSlider').addEventListener('input', e => {
      document.getElementById('irValue').textContent = e.target.value + "%";
      let scale = e.target.value / 100;
      mergeAndDisplay(scale);
    });
  </script>
</body>
</html>
