<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Aerochrome Simulator iPhone-Ready</title>
<style>
  body { font-family: system-ui, sans-serif; padding: 12px; max-width: 900px; margin:auto; }
  canvas { max-width:100%; border:1px solid #ccc; margin-top:10px; }
  label { display:block; margin-top:8px; }
  #status { margin-top:10px; font-weight:bold; color:green; }
</style>
<script src="https://docs.opencv.org/4.x/opencv.js"></script>
</head>
<body>
<h1>Aerochrome Simulator</h1>
<p>Upload an IR image and a normal image. Auto-align + channel mapping: R=IR, G=Red, B=Green. Use slider to boost red.</p>

<label>IR image: <input id="irFile" type="file" accept="image/*"></label>
<label>Visible image: <input id="visFile" type="file" accept="image/*"></label>
<label>Red boost: <input type="range" id="redBoost" min="1" max="3" step="0.1" value="1"></label>
<button id="process">Process</button>
<button id="download">Download PNG</button>

<div id="status">Waiting for OpenCV...</div>
<canvas id="canvas"></canvas>

<script>
let irImg=null, visImg=null;
const canvas=document.getElementById('canvas');
const ctx=canvas.getContext('2d');
const status=document.getElementById('status');
const redBoostSlider=document.getElementById('redBoost');

function loadImage(file, cb){
  const url=URL.createObjectURL(file);
  const img=new Image();
  img.onload=()=>{ URL.revokeObjectURL(url); cb(img); };
  img.src=url;
}

document.getElementById('irFile').onchange=e=>{ if(e.target.files[0]) loadImage(e.target.files[0], img=>{ irImg=img; status.textContent="IR image loaded"; }) }
document.getElementById('visFile').onchange=e=>{ if(e.target.files[0]) loadImage(e.target.files[0], img=>{ visImg=img; status.textContent="Visible image loaded"; }) }

// Poll for OpenCV.js readiness
function waitForCV(callback){
  if(typeof cv !== 'undefined' && cv.Mat){
      callback();
  } else {
      setTimeout(()=>waitForCV(callback), 100);
  }
}

waitForCV(()=>{
  status.textContent="OpenCV ready!";

  document.getElementById('process').onclick=()=>{
    if(!irImg || !visImg){ status.textContent="Load both images first"; return; }
    status.textContent="Processing...";

    const maxWidth=400;
    function resizeCanvas(img){
      const scale=Math.min(1, maxWidth/img.width);
      const w=Math.round(img.width*scale);
      const h=Math.round(img.height*scale);
      const c=document.createElement('canvas');
      c.width=w; c.height=h;
      c.getContext('2d').drawImage(img,0,0,w,h);
      return c;
    }
    const irCanvas=resizeCanvas(irImg);
    const visCanvas=resizeCanvas(visImg);

    let irMat=cv.imread(irCanvas);
    let visMat=cv.imread(visCanvas);

    // Grayscale for alignment
    let irGray=new cv.Mat();
    let visGray=new cv.Mat();
    cv.cvtColor(irMat, irGray, cv.COLOR_RGBA2GRAY);
    cv.cvtColor(visMat, visGray, cv.COLOR_RGBA2GRAY);

    // AKAZE feature detection (more robust than ORB)
    let detector=new cv.AKAZE();
    let kp1=new cv.KeyPointVector(), kp2=new cv.KeyPointVector();
    let des1=new cv.Mat(), des2=new cv.Mat();
    detector.detectAndCompute(irGray, new cv.Mat(), kp1, des1);
    detector.detectAndCompute(visGray, new cv.Mat(), kp2, des2);

    let bf=new cv.BFMatcher(cv.NORM_HAMMING,true);
    let matches=new cv.DMatchVector();
    bf.match(des1, des2, matches);

    if(matches.size()<4){ status.textContent="Not enough matches to align"; return; }

    // Extract points
    let pts1=[], pts2=[];
    for(let i=0;i<matches.size();i++){
      let m=matches.get(i);
      pts1.push(kp1.get(m.queryIdx).pt);
      pts2.push(kp2.get(m.trainIdx).pt);
    }
    let srcPts=cv.matFromArray(pts1.length,1,cv.CV_32FC2,[].concat(...pts1.map(p=>[p.x,p.y])));
    let dstPts=cv.matFromArray(pts2.length,1,cv.CV_32FC2,[].concat(...pts2.map(p=>[p.x,p.y])));

    let H=cv.findHomography(srcPts,dstPts,cv.RANSAC);

    let alignedIR=new cv.Mat();
    cv.warpPerspective(irMat, alignedIR, H, new cv.Size(visMat.cols, visMat.rows));

    // Split visible channels
    let visChannels=new cv.MatVector();
    cv.split(visMat, visChannels);
    let visR=visChannels.get(0);
    let visG=visChannels.get(1);

    // IR â†’ grayscale
    let irGrayAligned=new cv.Mat();
    cv.cvtColor(alignedIR, irGrayAligned, cv.COLOR_RGBA2GRAY);

    // Apply red boost from slider
    let boost=parseFloat(redBoostSlider.value);
    let irFloat=new cv.Mat();
    irGrayAligned.convertTo(irFloat, cv.CV_32F);
    cv.multiply(irFloat, new cv.Scalar(boost), irFloat);
    cv.min(irFloat, new cv.Mat(irFloat.rows, irFloat.cols, cv.CV_32F, 255), irFloat);
    irFloat.convertTo(irGrayAligned, cv.CV_8U);
    irFloat.delete();

    // Compose output
    let out=new cv.Mat();
    let outChannels=new cv.MatVector();
    outChannels.push_back(irGrayAligned); // R=IR
    outChannels.push_back(visR);          // G=Vis.R
    outChannels.push_back(visG);          // B=Vis.G
    cv.merge(outChannels,out);

    canvas.width=out.cols; canvas.height=out.rows;
    cv.imshow(canvas,out);
    status.textContent="Done!";

    // Cleanup
    irMat.delete(); visMat.delete();
    irGray.delete(); visGray.delete();
    kp1.delete(); kp2.delete(); des1.delete(); des2.delete(); matches.delete(); bf.delete(); detector.delete();
    srcPts.delete(); dstPts.delete(); H.delete();
    alignedIR.delete(); irGrayAligned.delete();
    visChannels.delete(); visR.delete(); visG.delete(); outChannels.delete();
  };
});

document.getElementById('download').onclick=()=>{
  const url=canvas.toDataURL("image/png");
  const a=document.createElement("a"); a.href=url; a.download="aerochrome.png"; a.click();
};
</script>
</body>
</html>
