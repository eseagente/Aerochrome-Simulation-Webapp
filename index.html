<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Aerochrome Simulator (AKAZE + Base Toggle)</title>
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    #status { margin: 10px 0; font-weight: bold; }
    canvas { margin-top: 10px; border: 1px solid #ccc; max-width: 100%; }
    label { display: block; margin-top: 10px; }
  </style>
</head>
<body>
  <h2>Aerochrome Simulator</h2>

  <label>IR Image: <input type="file" id="irInput" accept="image/*"></label>
  <label>Normal Image: <input type="file" id="visInput" accept="image/*"></label>

  <label>
    <input type="checkbox" id="irAsBase"> Use IR image as base (visible image will be warped)
  </label>

  <label>IR intensity (red channel): <input type="range" id="irSlider" min="0" max="200" value="100"> <span id="irValue">100%</span></label>

  <button id="processBtn">Process</button>
  <div id="status">Waiting for input…</div>
  <canvas id="output"></canvas>

  <script>
    let irImg = null, visImg = null;
    let alignedMov = null; 
    let refMatGlobal = null;

    function updateStatus(msg) {
      document.getElementById('status').textContent = msg;
      console.log(msg);
    }

    function loadImage(file, callback) {
      let img = new Image();
      img.onload = () => callback(img);
      img.src = URL.createObjectURL(file);
    }

    function resizeImage(img, maxW = 1200) {
      let scale = Math.min(1, maxW / img.width);
      let canvas = document.createElement('canvas');
      canvas.width = img.width * scale;
      canvas.height = img.height * scale;
      let ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      return cv.imread(canvas);
    }

    function mergeAndDisplay(scale = 1.0) {
      if (!alignedMov || !refMatGlobal) return;

      let refChannels = new cv.MatVector();
      cv.split(refMatGlobal, refChannels);

      let movChannels = new cv.MatVector();
      cv.split(alignedMov, movChannels);

      let irIsBase = document.getElementById('irAsBase').checked;

      let irChannel = irIsBase ? refChannels.get(0) : movChannels.get(0);
      irChannel.convertTo(irChannel, -1, scale, 0); // apply slider scale

      let greenChannel = irIsBase ? movChannels.get(0) : refChannels.get(0);
      let blueChannel = irIsBase ? movChannels.get(1) : refChannels.get(1);

      let outChannels = new cv.MatVector();
      outChannels.push_back(irChannel);
      outChannels.push_back(greenChannel);
      outChannels.push_back(blueChannel);

      let merged = new cv.Mat();
      cv.merge(outChannels, merged);

      let displayMat = new cv.Mat();
      let maxDisplay = 800;
      let scaleDisplay = Math.min(1, maxDisplay / merged.cols);
      cv.resize(merged, displayMat, new cv.Size(Math.round(merged.cols * scaleDisplay), Math.round(merged.rows * scaleDisplay)));

      cv.imshow("output", displayMat);

      refChannels.delete(); movChannels.delete(); outChannels.delete(); merged.delete(); displayMat.delete();
    }

    function process() {
      if (!irImg || !visImg) {
        updateStatus("Please upload both images.");
        return;
      }

      updateStatus("Starting…");

      let irMat = resizeImage(irImg, 1200);
      let visMat = resizeImage(visImg, 1200);

      let irIsBase = document.getElementById('irAsBase').checked;

      let refMat = irIsBase ? irMat : visMat;
      let movMat = irIsBase ? visMat : irMat;

      updateStatus("Converting to grayscale for alignment…");
      let refGray = new cv.Mat();
      let movGray = new cv.Mat();
      cv.cvtColor(refMat, refGray, cv.COLOR_RGBA2GRAY);
      cv.cvtColor(movMat, movGray, cv.COLOR_RGBA2GRAY);

      updateStatus("Detecting keypoints with AKAZE…");
      let detector = new cv.AKAZE();
      let kp1 = new cv.KeyPointVector(), kp2 = new cv.KeyPointVector();
      let des1 = new cv.Mat(), des2 = new cv.Mat();
      detector.detectAndCompute(movGray, new cv.Mat(), kp1, des1);
      detector.detectAndCompute(refGray, new cv.Mat(), kp2, des2);

      updateStatus("Matching keypoints…");
      let bf = new cv.BFMatcher(cv.NORM_HAMMING, false);
      let matches = new cv.DMatchVectorVector();
      bf.knnMatch(des1, des2, matches, 2);

      let good = [];
      for (let i = 0; i < matches.size(); i++) {
        let m = matches.get(i).get(0);
        let n = matches.get(i).get(1);
        if (m.distance < 0.75 * n.distance) good.push(m);
      }

      if (good.length < 4) {
        updateStatus("Not enough matches, skipping alignment.");
        alignedMov = movMat.clone();
      } else {
        updateStatus("Computing homography…");
        let srcPts = [], dstPts = [];
        for (let m of good) {
          srcPts.push(kp1.get(m.queryIdx).pt.x, kp1.get(m.queryIdx).pt.y);
          dstPts.push(kp2.get(m.trainIdx).pt.x, kp2.get(m.trainIdx).pt.y);
        }
        let src = cv.matFromArray(good.length, 1, cv.CV_32FC2, srcPts);
        let dst = cv.matFromArray(good.length, 1, cv.CV_32FC2, dstPts);
        let H = cv.findHomography(src, dst, cv.RANSAC);

        if (H.empty()) {
          updateStatus("Homography failed, skipping alignment.");
          alignedMov = movMat.clone();
        } else {
          updateStatus("Warping moving image…");
          alignedMov = new cv.Mat();
          cv.warpPerspective(movMat, alignedMov, H, new cv.Size(refMat.cols, refMat.rows));
        }

        src.delete(); dst.delete(); H.delete();
      }

      refMatGlobal = refMat.clone();

      let scale = document.getElementById('irSlider').value / 100;
      updateStatus("Merging channels…");
      mergeAndDisplay(scale);

      updateStatus("Done!");

      irMat.delete(); visMat.delete(); refGray.delete(); movGray.delete();
      kp1.delete(); kp2.delete(); des1.delete(); des2.delete();
      detector.delete(); bf.delete(); matches.delete();
    }

    function waitForCV(callback) {
      if (cv && cv.Mat) callback();
      else setTimeout(() => waitForCV(callback), 100);
    }

    document.getElementById('processBtn').addEventListener('click', () => waitForCV(process));
    document.getElementById('irInput').addEventListener('change', e => loadImage(e.target.files[0], img => irImg = img));
    document.getElementById('visInput').addEventListener('change', e => loadImage(e.target.files[0], img => visImg = img));

    document.getElementById('irSlider').addEventListener('input', e => {
      document.getElementById('irValue').textContent = e.target.value + "%";
      let scale = e.target.value / 100;
      mergeAndDisplay(scale);
    });
    document.getElementById('irAsBase').addEventListener('change', () => {
      if(irImg && visImg) process(); // reprocess if base changes
    });
  </script>
</body>
</html>
