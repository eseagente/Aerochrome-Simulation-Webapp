<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Aerochrome Simulator</title>
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    #status { margin: 10px 0; font-weight: bold; }
    canvas { margin-top: 10px; border: 1px solid #ccc; max-width: 100%; }
  </style>
</head>
<body>
  <h2>Aerochrome Simulator 4</h2>
  <label>IR Image: <input type="file" id="irInput" accept="image/*"></label><br><br>
  <label>Normal Image: <input type="file" id="visInput" accept="image/*"></label><br><br>
  <button id="processBtn">Process</button>
  <div id="status">Waiting for input…</div>
  <canvas id="output"></canvas>

  <script>
    let irImg = null, visImg = null;

    function updateStatus(msg) {
      document.getElementById('status').textContent = msg;
      console.log(msg);
    }

    function loadImage(file, callback) {
      let img = new Image();
      img.onload = () => callback(img);
      img.src = URL.createObjectURL(file);
    }

    function resizeImage(img, maxW = 500) {
      let scale = Math.min(1, maxW / img.width);
      let canvas = document.createElement('canvas');
      canvas.width = img.width * scale;
      canvas.height = img.height * scale;
      let ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      return cv.imread(canvas);
    }

    function process() {
      if (!irImg || !visImg) {
        updateStatus("Please upload both images.");
        return;
      }

      updateStatus("Starting…");

      let irMat = resizeImage(irImg, 500);
      let visMat = resizeImage(visImg, 500);

      updateStatus("Converting to grayscale for alignment…");
      let irGray = new cv.Mat(), visGray = new cv.Mat();
      cv.cvtColor(irMat, irGray, cv.COLOR_RGBA2GRAY);
      cv.cvtColor(visMat, visGray, cv.COLOR_RGBA2GRAY);

      updateStatus("Detecting keypoints with ORB…");
      let detector = new cv.ORB(200);
      let kp1 = new cv.KeyPointVector(), kp2 = new cv.KeyPointVector();
      let des1 = new cv.Mat(), des2 = new cv.Mat();
      detector.detectAndCompute(irGray, new cv.Mat(), kp1, des1);
      detector.detectAndCompute(visGray, new cv.Mat(), kp2, des2);

      updateStatus("Matching keypoints…");
      let bf = new cv.BFMatcher(cv.NORM_HAMMING, false);
      let matches = new cv.DMatchVectorVector();
      bf.knnMatch(des1, des2, matches, 2);

      let good = [];
      for (let i = 0; i < matches.size(); i++) {
        let m = matches.get(i).get(0);
        let n = matches.get(i).get(1);
        if (m.distance < 0.75 * n.distance) good.push(m);
      }

      let alignedIR = new cv.Mat();
      if (good.length < 4) {
        updateStatus("Not enough matches, skipping alignment.");
        alignedIR = irMat.clone();
      } else {
        updateStatus("Computing homography…");
        let srcPts = [], dstPts = [];
        for (let m of good) {
          srcPts.push(kp1.get(m.queryIdx).pt.x, kp1.get(m.queryIdx).pt.y);
          dstPts.push(kp2.get(m.trainIdx).pt.x, kp2.get(m.trainIdx).pt.y);
        }
        let src = cv.matFromArray(good.length, 1, cv.CV_32FC2, srcPts);
        let dst = cv.matFromArray(good.length, 1, cv.CV_32FC2, dstPts);
        let H = cv.findHomography(src, dst, cv.RANSAC);

        if (H.empty()) {
          updateStatus("Homography failed, skipping alignment.");
          alignedIR = irMat.clone();
        } else {
          updateStatus("Warping IR image…");
          cv.warpPerspective(irMat, alignedIR, H, new cv.Size(visMat.cols, visMat.rows));
        }

        src.delete(); dst.delete(); H.delete();
      }

      updateStatus("Merging channels…");
      let visChannels = new cv.MatVector();
      cv.split(visMat, visChannels);
      let irChannels = new cv.MatVector();
      cv.split(alignedIR, irChannels);

      let merged = new cv.Mat();
      let outChannels = new cv.MatVector();
      outChannels.push_back(irChannels.get(0));      // IR → Red
      outChannels.push_back(visChannels.get(0));     // Red → Green
      outChannels.push_back(visChannels.get(1));     // Green → Blue
      cv.merge(outChannels, merged);

      cv.imshow("output", merged);

      updateStatus("Done!");

      // cleanup
      irMat.delete(); visMat.delete();
      irGray.delete(); visGray.delete();
      kp1.delete(); kp2.delete();
      des1.delete(); des2.delete();
      detector.delete(); bf.delete(); matches.delete();
      visChannels.delete(); irChannels.delete(); outChannels.delete();
      merged.delete(); alignedIR.delete();
    }

    function waitForCV(callback) {
      if (cv && cv.Mat) callback();
      else setTimeout(() => waitForCV(callback), 100);
    }

    document.getElementById('processBtn').addEventListener('click', () => {
      waitForCV(process);
    });

    document.getElementById('irInput').addEventListener('change', e => {
      loadImage(e.target.files[0], img => irImg = img);
    });
    document.getElementById('visInput').addEventListener('change', e => {
      loadImage(e.target.files[0], img => visImg = img);
    });
  </script>
</body>
</html>
